操作系统基础知识
====
## 知识列表
#### 小知识点


#### 线程与进程的区别
+ 地址空间： 进程拥有独立的地址空间，而线程共用地址空间
+ 线程是处理器调度的最小单位，线程是资源分配的最小单位
+ 页面置换算法: LRU, LFU, FIFO, 随机置换

#### 同步机制应该遵循的基本准则
+ 空闲让进
+ 忙则等待
+ 有限等待
+ 让权等待



#### 并发问题
并发操作是指同一时间有多个用户对同一数据进行读写操作，会造成数据的不完整性，包括：丢失修改，读脏数据和不可重复读。
+ **丢失修改：** 两用户同时读，然后都在此基础上修改，则其中一方的修改丢失
+ **读脏数据：** 用户一读到用户二修改的数据，但是用户二撤消修改，则用户一读到的是脏数据
+ **不可重复读：** 用户两次读之间另一用户进行了修改

保证并发调度的正确性的方法是二段封锁协议，但是二段封锁协议可能会发生死锁，如果需要防止死锁，可以使用一次封锁协议，即每个事务必须一次性将所有要使用的数据全部加锁，否则不能执行。


#### 进程调度
###### 进程间切换的步骤：
进程切换需要切换虚拟空间、内核栈、cpu寄存器、内核空间的切换。

1. 保存程序计数其以及其他寄存器。
2. 更新当前处于“运行态”的进程的进程控制块，把进程状态改为相应状态，更新其他相关域
3. 把被切换进程的进程控制块移到相关状态的队列
4. 选择另外一个进程开始执行，把该进程进程控制块的状态改为“运行态”
5. 恢复被选择进程的处理器在最近一次被切换出运行态时的上下文，比如载入程序计数器以及其他处理器的值
6. 进程间切换伴随着两次模式切换（用户--内核，内核--用户）

###### 线程间切换的步骤：
线程分两种，用户级线程和内核级线程：

+ 在用户级线程中，有关线程管理的所有工作都由应用程序完成，内核没有意识到线程的存在，用户级线程间切换时，只需要保存用户寄存器的内容，程序计数器，栈指针，不需要模式切换。在进程的某个线程执行系统调用时，不仅该线程被阻塞，该线程所在进程的所有线程都被阻塞，无法利用多处理器
+ 在内核级线程中，有关线程的管理工作都是由内核完成的，应用程序部分没有线程管理的权限，内核级线程间切换时，除了保存上下文，还要进行模式切换。可以利用多处理器，线程阻塞不会导致进程阻塞


#### 死锁
###### 死锁的产生原因
+ 资源不足
+ 资源分配不当
+ 进程运行推进的顺序不合适

###### 死锁的条件
+ **互斥：** 存在互斥资源(假脱机技术)
+ **持有并等待：** 当请求的起源被占用而阻塞时不释放已获得的资源(执行前一次性获取资源)
+ **不可剥夺：** 不可强行剥夺已获得的互斥资源
+ **环形等待：** 以不同顺序请求资源而形成环形等待的局面(资源统一编号顺序请求)

###### 死锁的避免
+ **死锁预防:** 预先静态分配法, 资源有序分配法
+ **死锁避免:** 银行家算法
+ 允许进程剥夺使用其他进程占有的资源
+ 锁管理器检测死锁，然后解除死锁(利用抢占恢复，利用回滚恢复，杀死进程恢复)



#### 内存管理
详细参见[网址](http://blog.csdn.net/hguisu/article/details/5713164)

+ 内存管理主要包括虚地址、地址变换、内存分配和回收、内存扩充、内存共享和保护等功能。
+ 连续分配有单一连续存储管理和分区式储管理两种方式。
+ 动态分区的特点是动态创建分区：在装入程序时按其初始要求分配，或在其执行过程中通过系统调用进行分配或改变分区大小。与固定分区相比较其优点是：没有内碎片。但它却引入了另一种碎片——外碎片
+ 覆盖技术的实现是把程序划分为若干个功能上相对独立的程序段，按照其自身的逻辑结构使那些不会同时运行的程序段共享同一块内存区域。程序段先保存在磁盘上，当有关程序的前一部分执行结束后，把后续程序段调入内存，覆盖前面的程序段。 
+ 交换技术：在分时系统中，用户的进程比内存能容纳的数量更多，系统将那些不再运行的进程或某一部分调出内存，暂时放在外存上的一个后备存储区，通常称为交换区，当需要运行这些进程时，再将它们装入内存

###### 分区式存储管理
+ 区式存储管理是把内存分为一些大小相等或不等的分区，操作系统占用其中一个分区，其余的分区由应用程序使用，每个应用程序占用一个或几个分区。分区式存储管理虽然可以支持并发，但难以进行内存分区的共享。
+ 分区式存储管理引人了两个新的问题：内碎片内碎片和外碎片。内碎片是占用分区内未被利用的空间，外碎片是占用分区之间难以利用的空闲分区(通常是小空闲分区)。
+ 为实现分区式存储管理，操作系统应维护的数据结构为分区表或分区链表。表中各表项一般包括每个分区的起始地址、大小及状态(是否已分配)。
+ 分区式存储管理常采用的一项技术就是内存紧缩(compaction)

###### 页式存储管理
将程序的逻辑地址空间划分为固定大小的页(page)，而物理内存划分为同样大小的页框(page frame)。程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。该方法需要CPU的硬件支持，来实现逻辑地址和物理地址之间的映射。在页式存储管理方式中地址结构由两部构成，前一部分是页号，后一部分为页内地址w（位移量）

###### 段式存储管理
在段式存储管理中，将程序的地址空间划分为若干个段(segment)，这样每个进程有一个二维的地址空间。在前面所介绍的动态分区分配方式中，系统为整个进程分配一个连续的内存空间。而在段式存储管理系统中，则为每个段分配一个连续的分区，而进程中的各个段可以不连续地存放在内存的不同分区中。程序加载时，操作系统为所有段分配其所需内存，这些段不必连续，物理内存的管理采用动态分区的管理方法。

#### 虚拟存储器
当程序的存储空间要求大于实际的内存空间时，就使得程序难以运行了。虚拟存储技术就是利用实际内存空间和相对大的多的外部储存器存储空间相结合构成一个远远大于实际内存空间的虚拟存储空间，程序就运行在这个虚拟存储空间中，能够实现虚拟存储的依据是程序的**局部性原理** **，即程序在运行过程中经常体现出运行在某个局部范围之内的特点

虚拟内存是把一个程序所需要的存储空间分成若干页或段，程序运行用到页和段就放在内存里，暂时不用就放在外存中。当用到外存中的页和段时，就把它们调到内存，反之就把它们送到外存中，装入内存中的页或段可以分散存放。

虚存管理和实存管理的主要区别是实存要求一程序全部装入内存才开始运行，虚存允许程序在执行的过程中逐步装入












